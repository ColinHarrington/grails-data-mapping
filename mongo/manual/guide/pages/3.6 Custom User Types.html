<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>3.6 Custom User Types</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    GORM for MongoDB will persist all common known Java types like String, Integer, URL etc., however if you want to persist one of your own classes that is not a domain class you can implement a custom user type. For example consider the following class:<p class="paragraph"/><div class="code"><pre>class Birthday <span class="java&#45;keyword">implements</span> Comparable&#123;
    Date date<p class="paragraph"/>    Birthday(Date date) &#123;
        <span class="java&#45;keyword">this</span>.date = date
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;object">int</span> compareTo(<span class="java&#45;object">Object</span> t) &#123;
        date.compareTo(t.date)
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Custom types should go in src/groovy not grails-app/domain
</blockquote><p class="paragraph"/>If you attempt to reference this class from a domain class it will not automatically be persisted for you. However you can create a custom type implementation and register it with the Spring. For example:<p class="paragraph"/><div class="code"><pre>class BirthdayType <span class="java&#45;keyword">extends</span> AbstractMappingAwareCustomTypeMarshaller&#60;Birthday, DBObject, DBObject&#62; &#123;
	BirthdayType() &#123;
		<span class="java&#45;keyword">super</span>(Birthday)
	&#125;
    @Override
    <span class="java&#45;keyword">protected</span> <span class="java&#45;object">Object</span> writeInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, Birthday value, DBObject nativeTarget) &#123;
        <span class="java&#45;keyword">final</span> converted = value.date.time
        nativeTarget.put(key, converted)
        <span class="java&#45;keyword">return</span> converted
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">protected</span> void queryInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, PropertyCriterion criterion, DBObject nativeQuery) &#123;
        <span class="java&#45;keyword">if</span>(criterion <span class="java&#45;keyword">instanceof</span> Between) &#123;
            def dbo = <span class="java&#45;keyword">new</span> BasicDBObject()
            dbo.put(MongoQuery.MONGO_GTE_OPERATOR, criterion.getFrom().date.time);
            dbo.put(MongoQuery.MONGO_LTE_OPERATOR, criterion.getTo().date.time);
            nativeQuery.put(key, dbo)
        &#125;
        <span class="java&#45;keyword">else</span> &#123;
            nativeQuery.put(key, criterion.value.date.time)
        &#125;<p class="paragraph"/>    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">protected</span> Birthday readInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, DBObject nativeSource) &#123;
        <span class="java&#45;keyword">final</span> num = nativeSource.get(key)
        <span class="java&#45;keyword">if</span>(num <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">Long</span>) &#123;
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date(num))
        &#125;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>The above <code>BirthdayType</code> class is a custom user type implementation for MongoDB for the <code>Birthday</code> class. It provides implementations for three methods: <code>readInternal</code>, <code>writeInternal</code> and the optional <code>queryInternal</code>. If you do not implement <code>queryInternal</code> your custom type can be persisted but not queried.<p class="paragraph"/>The <code>writeInternal</code> method gets passed the property, the key to store it under, the value and the native DBObject where the custom type is to be stored:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> <span class="java&#45;object">Object</span> writeInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, Birthday value, DBObject nativeTarget) &#123;
    <span class="java&#45;keyword">final</span> converted = value.date.time
    nativeTarget.put(key, converted)
    <span class="java&#45;keyword">return</span> converted
&#125;</pre></div><p class="paragraph"/>You can then read the values of the custom type and register them with the <code>DBObject</code>. The <code>readInternal</code> method gets passed the <code>PersistentProperty</code>, the key the user type info is stored under (although you may want to use multiple keys) and the <code>DBObject</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> Birthday readInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, DBObject nativeSource) &#123;
    <span class="java&#45;keyword">final</span> num = nativeSource.get(key)
    <span class="java&#45;keyword">if</span>(num <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">Long</span>) &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date(num))
    &#125;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
&#125;</pre></div><p class="paragraph"/>You can the construct the custom type from by reading values from the <code>DBObject</code>. Finally the <code>queryInternal</code> method allows you to handle how a custom type is queried:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void queryInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, PropertyCriterion criterion, DBObject nativeQuery) &#123;
    <span class="java&#45;keyword">if</span>(criterion <span class="java&#45;keyword">instanceof</span> Between) &#123;
        def dbo = <span class="java&#45;keyword">new</span> BasicDBObject()
        dbo.put(MongoQuery.MONGO_GTE_OPERATOR, criterion.getFrom().date.time);
        dbo.put(MongoQuery.MONGO_LTE_OPERATOR, criterion.getTo().date.time);
        nativeQuery.put(key, dbo)
    &#125;
    <span class="java&#45;keyword">else</span> <span class="java&#45;keyword">if</span>(criterion <span class="java&#45;keyword">instanceof</span> Equals)&#123;
        nativeQuery.put(key, criterion.value.date.time)
    &#125;
    <span class="java&#45;keyword">else</span> &#123;
	    <span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> RuntimeException(<span class="java&#45;quote">"unsupported query type <span class="java&#45;keyword">for</span> property $property"</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>The method gets passed a <code>criterion</code> which is the type of query and depending on the type of query you may handle the query differently. For example the above implementation supports <code>between</code> and <code>equals</code> style queries. So the following 2 queries will work:<p class="paragraph"/><div class="code"><pre>Person.findByBirthday(<span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date()&#45;7)) // find someone who was born 7 days ago
Person.findByBirthdayBetween(<span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date()&#45;7), <span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date())) // find someone who was born in the last 7 days</pre></div><p class="paragraph"/>However "like" or other query types will not work.
    </body>
</html>
